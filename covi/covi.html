<html>

<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.6.0/dist/leaflet.css" />
    <style>
        .legend {
            color: white;
            text-align: left;
            line-height: 18px;
        }

        .legend i {
            width: 18px;
            height: 18px;
            float: left;
            margin-right: 8px;
            opacity: 0.7;
        }
    </style>
</head>

<body>
    <div id="mapid" style="width: 100%; height: 100%"></div>

    <script src="https://unpkg.com/leaflet@1.6.0/dist/leaflet.js"></script>
    <script src="https://elfalem.github.io/Leaflet.curve/src/leaflet.curve.js"></script>
    <script src="./theme.js?1"></script>

    <script>
        // load map
        var myMap = L.map("mapid").setView([15.792, 107.403], 6);

        var theme = themes.CartoDB_DarkMatter;
        theme.tile.addTo(myMap);

        var legend = L.control({ position: 'bottomright' });
        legend.onAdd = function (map) {
            var _div = L.DomUtil.create('div', 'info legend');
            _div.innerHTML = `<i style="background: ${theme.color.directNew}"></i> Ca dương tính mới<br>
<i style="background: ${theme.color.directOld}"></i> Ca dương tính cũ<br>
<i style="background: ${theme.color.indirect}"></i> Địa điểm liên quan<br>`;
            return _div;
        };
        legend.addTo(myMap);



        function parseGoogleMap(url) {
            data = /@([-.\d]+),([-.\d]+),/.exec(url);
            lat = parseFloat(data[1]);
            lng = parseFloat(data[2]);
            return [lat, lng];
        }

        var cases = {};
        var locations = {};

        async function LoadData() {
            const _cases = [
                "no17",
                "no22",
                "no23",
                "no27",
                "no28",
            ];

            for (var i = 0; i < _cases.length; i++) {
                var caseNo = _cases[i];
                var response = await fetch(`./cases/${caseNo}.json`);
                cases[caseNo] = await response.json();
            }

            Process();
        }

        LoadData();

        function Process() {

            var isMarkerArr = false;
            var markerArr = Array();

            // cases schedule -> locations
            count = 0;
            for (const [key, ca] of Object.entries(cases)) {
                count++;
                var locRoot, locLeaf;

                ca.edge = Array();
                ca.arrLocs = Array();
                ca.rootLocs = Array();
                ca.leafLocs = Array();

                for ([locName, loc] of Object.entries(ca.nodes)) {
                    // parse google map
                    if ("url" in loc) {
                        [loc.lat, loc.lng] = parseGoogleMap(loc.url);
                    }

                    // duplicate in name
                    var isDup = false;
                    if (locName in locations) {
                        isDup = true;
                    } else {
                        for ([tmpName, tmpLoc] of Object.entries(locations)) {
                            if (tmpLoc.lat == loc.lat && tmpLoc.lng == loc.lng) {
                                // duplicate in lat - lng
                                locName = tmpName;
                                isDup = true;
                                break;
                            }
                        }
                    }
                    if (!isDup) {
                        // not duplicate -> add to map
                        locations[locName] = loc;
                    }

                    var wrapLoc = locations[locName]; // == loc in [lat, lng]
                    ca.arrLocs.push(locName);

                    if (!("link" in wrapLoc)) {
                        wrapLoc.link = Array();
                    }

                    var linkType;
                    if (loc.last) {
                        linkType = ca.caseType; // new - old
                        ca.rootLocs.push([loc.lat, loc.lng]);
                    } else {
                        linkType = "indirect"; // indirect
                        ca.leafLocs.push([loc.lat, loc.lng]);
                    }

                    wrapLoc.link.push([key, linkType]);
                };

                // if has at least 1 rootLocs
                for (var i = 0; i < ca.rootLocs.length; i++) {
                    for (var j = 0; j < ca.leafLocs.length; j++) {
                        var locRoot = ca.rootLocs[i],
                            locLeaf = ca.leafLocs[j];

                        // calc Bézier curve between root -> leaf
                        var offsetX = locRoot[1] - locLeaf[1],
                            offsetY = locRoot[0] - locLeaf[0];
                        var r = Math.sqrt(Math.pow(offsetX, 2) + Math.pow(offsetY, 2)),
                            theta = Math.atan2(offsetY, offsetX);
                        var thetaOffset = (3.14 / 10);
                        var r2 = (r / 2) / (Math.cos(thetaOffset)),
                            theta2 = theta + thetaOffset;

                        var midpointX = (r2 * Math.cos(theta2)) + locLeaf[1],
                            midpointY = (r2 * Math.sin(theta2)) + locLeaf[0];
                        var midpointLatLng = [midpointY, midpointX];

                        // generate line between root -> leaf
                        var line = L.curve(["M", locRoot, "Q", midpointLatLng, locLeaf], {
                            weight: 2,
                            color: theme.color.line,
                            //color: myColor,
                            animate: {
                                duration: 1000,
                            }
                        });
                        ca.edge.push(line);
                    }
                }
            }

            for (const [_, loc] of Object.entries(locations)) {
                var color;

                var isNew = false;
                var linkDirect = Array(),
                    linkIndirect = Array();
                loc.link.forEach(([caseNo, linkType]) => {
                    if (linkType == "new") {
                        isNew = true;
                    }

                    if (linkType == "indirect") {
                        if (linkIndirect.indexOf(caseNo) < 0) {
                            linkIndirect.push(caseNo);
                        }
                    } else {
                        if (linkDirect.indexOf(caseNo) < 0) {
                            linkDirect.push(caseNo);
                        }
                    }
                });

                var desc = `Location: <a href="https://www.google.com/maps/@${loc.lat},${loc.lng},17z/" target="_blank">${loc.desc}</a><br>`;
                if (linkDirect.length != 0) {
                    if (isNew) {
                        color = theme.color.directNew;
                    } else {
                        color = theme.color.directOld;
                    }

                    var descDirect = "";
                    var descCase = "";
                    var descAge = "";
                    var descGender = "";
                    var descConfirm, descFrom, descCiti, descStayed, descVisited;
                    linkDirect.forEach(caseNo => {
                        ca = cases[caseNo];
                        descCase += `<a href="#">#${caseNo}</a> `;
                        descAge += `${ca.age} `;
                        descGender += `${ca.gender} `;
                        descConfirm = ca.confirmDate;
                        descFrom = ca.from;
                        descCiti = ca.citizenship;
                        descStayed = ca.stayed;
                        descVisited = ca.visited;

                        if (ca.relatedCaseNo.length != 0) {
                            ca.relatedCaseNo.forEach(conNo => {
                                descDirect += `<a href="#">#${conNo}</a> `;
                            });
                        }
                    });
                    if (descDirect != "") {
                        descDirect = `Direct connection: ${descDirect}<br>`;
                    }
                    desc += `Ca số: ${descCase}<br>
Confirmed on: ${descConfirm}<br>
${descDirect}
Age: ${descAge}<br>
Gender: ${descGender}<br>
From: ${descFrom}<br>
Citizenship: ${descCiti}<br>
Visited: ${descVisited}<br>
Stayed: ${descStayed}<br>`;
                } else {
                    color = theme.color.indirect;
                }

                if (linkIndirect.length != 0) {
                    var descIncase = "";
                    linkIndirect.forEach(caseNo => {
                        ca = cases[caseNo];
                        descIncase += `<a href="#">#${caseNo}</a> `;
                    })
                    desc += `Related To Case: ${descIncase}<br>`;
                }

                var marker = L.circleMarker([loc.lat, loc.lng], {
                    stroke: false,
                    fill: true,
                    fillColor: color,
                    fillOpacity: theme.opacity.enable,
                }).addTo(myMap);

                loc.marker = marker;

                if (!("link" in loc)) {
                    loc.link = Array();
                }

                var popup = L.popup();
                popup.setContent(desc);
                marker.bindPopup(popup);

                marker.on("mouseup", function () {
                    isMarkerArr = markerArr.indexOf(this) != -1;
                })

                marker.on("popupopen", () => {
                    // popup another node in pool, reset flag, do nothing
                    if (isMarkerArr) {
                        isMarkerArr = false;
                        return;
                    }

                    // disable all node
                    for ([__, loc2] of Object.entries(locations)) {
                        loc2.marker.setStyle({
                            fillOpacity: theme.opacity.disable
                        });
                    }

                    // all cases link to this node
                    markerArr = Array();
                    loc.link.forEach(([caseNo, linkType]) => {
                        var ca = cases[caseNo];

                        // show edge between related nodes
                        ca.edge.forEach(line => {
                            line.addTo(myMap);
                        });

                        // enable all related nodes
                        ca.arrLocs.forEach(locName => {
                            loc3 = locations[locName];
                            loc3.marker.setStyle({
                                fillOpacity: theme.opacity.enable
                            });
                            loc3.marker.bringToFront();
                            markerArr.push(loc3.marker);
                        });
                    });

                    // enable this node in case no root link ?
                    loc.marker.setStyle({
                        fillOpacity: theme.opacity.enable
                    });
                    loc.marker.bringToFront();
                });

                marker.on("popupclose", () => {
                    // popup another node in pool, do nothing
                    if (isMarkerArr) {
                        return;
                    } else {
                        // reset pool
                        markerArr = Array();
                    }

                    // all cases link to this node
                    loc.link.forEach(([caseNo, linkType]) => {
                        var ca = cases[caseNo];

                        // hide edge between related nodes
                        ca.edge.forEach(line => {
                            line.remove();
                        });
                    });

                    // enable all node
                    for ([__, loc2] of Object.entries(locations)) {
                        loc2.marker.setStyle({
                            fillOpacity: theme.opacity.enable
                        });
                    }
                });

            }

        }

    </script>
</body>

</html>